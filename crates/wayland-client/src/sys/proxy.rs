//! Thin wrapper around libwayland `wl_proxy` implementation

use crate::{ffi, object::WlObjectId};
use core::fmt;
use std::{
    cmp::Ordering,
    ffi::{CStr, c_void},
    hash, mem,
    ptr::{self, NonNull},
    slice, str,
    sync::atomic::{
        AtomicUsize,
        Ordering::{Acquire, Release},
    },
};
use wayland_sys::{wl_event_queue, wl_proxy};

/// Represents a proxy object created on the libwayland backend
pub struct WlProxy {
    raw: NonNull<wl_proxy>,
    interface_name_length: AtomicUsize,
}

// # Safety
//
// - `WlProxy` does not provide interior mutability
// - `WlProxy` itself is a reference
unsafe impl Send for WlProxy {}

// Safety: `WlProxy` does not provide interior mutability
unsafe impl Sync for WlProxy {}

impl WlProxy {
    /// # Safety
    ///
    /// - `raw` should be a valid object generated by libwayland
    /// - nobody has any access to this object
    #[inline(always)]
    pub const unsafe fn from_raw(raw: NonNull<wl_proxy>) -> Self {
        Self {
            raw,
            interface_name_length: AtomicUsize::new(0),
        }
    }

    /// Raw proxy (opaque pointer to the libwayland backend)
    #[inline(always)]
    pub const fn as_raw(&self) -> NonNull<wl_proxy> {
        self.raw
    }

    /// Turns [`WlProxy`] into its raw value without calling the destructor
    #[inline(always)]
    pub const fn into_raw(self) -> NonNull<wl_proxy> {
        let raw = self.raw;
        mem::forget(self);
        raw
    }

    /// The id for the proxy object
    #[inline(always)]
    pub fn id(&self) -> WlObjectId {
        // Safety: calling this on a valid object is safe
        let raw = unsafe { ffi::wl_proxy_get_id(self.raw.as_ptr()) };

        // Safety: any valid object in libwayland has nonzero id
        // `WlProxy`'s safety guarantees `self` is a valid object
        unsafe { WlObjectId::try_from(raw).unwrap_unchecked() }
    }

    /// A name of the interface which the proxy implements
    pub fn interface_name(&self) -> &str {
        // Safety: calling this on a valid object is safe
        let ptr = unsafe { ffi::wl_proxy_get_class(self.raw.as_ptr()) };

        let len = self.interface_name_length.load(Acquire);

        let string_bytes = if len == 0 {
            // Safety: interface name obtained from libwayland is a valid c-string
            let c_str = unsafe { CStr::from_ptr(ptr) };

            self.interface_name_length
                .store(c_str.count_bytes(), Release);

            c_str.to_bytes()
        } else {
            // Safety: there exactly `len` bytes in the string (excluding nul-terminator)
            unsafe { slice::from_raw_parts(ptr.cast::<u8>(), len) }
        };

        // Safety: interface name obtained from libwayland contains
        // only valid ASCII characters
        unsafe { str::from_utf8_unchecked(string_bytes) }
    }

    /// Reads a user data pointer from [`wl_proxy`]
    #[inline(always)]
    pub(crate) fn get_user_data(&self) -> *mut c_void {
        // Safety: calling this on a valid object is safe
        unsafe { ffi::wl_proxy_get_user_data(self.as_raw().as_ptr()) }
    }

    /// Sets user data pointer for this [`wl_proxy`]
    ///
    /// # Note
    ///
    /// This function is safe, because it will not dereference the `data`.
    /// It means that any pointer can be written here
    #[allow(dead_code, clippy::not_unsafe_ptr_arg_deref)]
    #[deprecated = "maybe unused"]
    #[inline(always)]
    pub(crate) fn set_user_data(&mut self, data: *mut c_void) {
        // # Safety
        //
        // - calling this on a valid object is safe
        // - it will not dereference this pointer
        unsafe { ffi::wl_proxy_set_user_data(self.as_raw().as_ptr(), data) };
    }

    /// # Safety
    ///
    /// `queue_ptr` should be a valid queue created by calling `wl_display_create_queue`
    #[inline(always)]
    pub(crate) unsafe fn set_queue_raw(&mut self, queue_ptr: *mut wl_event_queue) {
        // # Safety
        //
        // - setting a variable requires `&mut self`
        // - calling this on a valid object is safe
        unsafe { ffi::wl_proxy_set_queue(self.as_raw().as_ptr(), queue_ptr) };
    }
}

impl Drop for WlProxy {
    fn drop(&mut self) {
        unsafe { ffi::wl_proxy_destroy(self.raw.as_ptr()) }
    }
}

impl PartialEq for WlProxy {
    fn eq(&self, other: &Self) -> bool {
        self.raw == other.raw
    }
}

impl Eq for WlProxy {}

impl fmt::Debug for WlProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("WlProxy")
            .field("id", &self.id())
            .field("interface", &self.interface_name())
            .finish_non_exhaustive()
    }
}

/// Can provide object id for object querying
#[derive(Clone, Copy)]
pub struct WlProxyQuery {
    raw: Option<NonNull<wl_proxy>>,
}

impl WlProxyQuery {
    /// Constructs [`WlProxyQuery`] from raw proxy pointer
    ///
    /// # Safety
    ///
    /// - `raw` should be a valid object or null
    pub const unsafe fn from_raw(raw: *const wl_proxy) -> Self {
        Self {
            raw: NonNull::new(raw.cast_mut()),
        }
    }

    /// Raw representation of the query
    pub const fn to_raw(self) -> *const wl_proxy {
        match self.raw {
            Some(ptr) => ptr.as_ptr().cast_const(),
            None => ptr::null(),
        }
    }

    /// Id of targeting proxy object
    pub fn id(self) -> Option<WlObjectId> {
        self.raw.and_then(|ptr| {
            // Safety: if `ptr` is nonnull then this `wl_proxy` should be valid
            let raw_id = unsafe { ffi::wl_proxy_get_id(ptr.as_ptr()) };
            WlObjectId::try_from(raw_id).ok()
        })
    }
}

impl fmt::Debug for WlProxyQuery {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("WlProxyQeury")
            .field("id", &self.id())
            .finish_non_exhaustive()
    }
}

impl PartialEq for WlProxyQuery {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl Eq for WlProxyQuery {}

impl PartialOrd for WlProxyQuery {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for WlProxyQuery {
    fn cmp(&self, other: &Self) -> Ordering {
        self.id().cmp(&other.id())
    }
}

impl hash::Hash for WlProxyQuery {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        hash::Hash::hash(&self.id(), state);
    }
}
