use super::ffi::{wl_proxy, wl_proxy_destroy, wl_proxy_get_class, wl_proxy_get_id};
use crate::object::ObjectId;
use core::fmt;
use std::{
    ffi::CStr,
    marker::PhantomData,
    mem::ManuallyDrop,
    ptr::NonNull,
    sync::atomic::{
        AtomicUsize,
        Ordering::{Acquire, Release},
    },
};

/// Represents a proxy object created on the libwayland backend
pub struct WlProxy {
    pub(crate) raw: NonNull<wl_proxy>,
    pub(crate) interface_name_length: AtomicUsize,
}

impl WlProxy {
    pub const unsafe fn from_raw(raw: NonNull<wl_proxy>) -> Self {
        Self {
            raw,
            interface_name_length: AtomicUsize::new(0),
        }
    }

    pub fn into_raw(self) -> NonNull<wl_proxy> {
        ManuallyDrop::new(self).raw
    }

    pub fn id(&self) -> ObjectId {
        // Safety: calling this on a valid object is safe
        let raw = unsafe { wl_proxy_get_id(self.raw.as_ptr()) };

        // Safety: any valid object in libwayland has nonzero id
        // `WlProxy`'s safety guarantees `self` is a valid object
        unsafe { ObjectId::try_from(raw).unwrap_unchecked() }
    }

    pub fn interface_name(&self) -> &str {
        // Safety: calling this on a valid object is safe
        let ptr = unsafe { wl_proxy_get_class(self.raw.as_ptr()) };

        let len = self.interface_name_length.load(Acquire);

        let string_bytes = if len == 0 {
            // Safety: interface name obtained from libwayland is a valid c-string
            let c_str = unsafe { CStr::from_ptr(ptr) };

            self.interface_name_length
                .store(c_str.count_bytes(), Release);

            c_str.to_bytes()
        } else {
            // Safety: there exactly `len` bytes in the string (excluding nul-terminator)
            unsafe { std::slice::from_raw_parts(ptr.cast::<u8>(), len) }
        };

        // Safety: interface name obtained from libwayland contains
        // only valid ASCII characters
        unsafe { std::str::from_utf8_unchecked(string_bytes) }
    }
}

impl Drop for WlProxy {
    fn drop(&mut self) {
        unsafe { wl_proxy_destroy(self.raw.as_ptr()) }
    }
}

impl PartialEq for WlProxy {
    fn eq(&self, other: &Self) -> bool {
        self.raw == other.raw
    }
}

impl Eq for WlProxy {}

impl fmt::Debug for WlProxy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct(std::any::type_name::<Self>())
            .finish_non_exhaustive()
    }
}

impl AsProxy for WlProxy {
    fn as_proxy(&self) -> WlProxyBorrow<'_> {
        unsafe { WlProxyBorrow::from_raw(self.raw) }
    }
}

/// The borrow of the proxy object
#[derive(Clone, Copy)]
pub struct WlProxyBorrow<'s> {
    pub raw: NonNull<wl_proxy>,
    pub _p: PhantomData<&'s WlProxy>,
}

impl<'s> WlProxyBorrow<'s> {
    /// Constructs [`WlProxyBorrow`] from raw pointer generated by libwayland backend
    ///
    /// # Safety
    ///
    /// - `value` should be valid [`wl_proxy`] pointer obtained from libwayland
    /// - no one has mutable access to the proxy object
    /// - the generated lifetime should be appropriate
    pub const unsafe fn from_raw(value: NonNull<wl_proxy>) -> Self {
        Self {
            raw: value,
            _p: PhantomData,
        }
    }

    /// Returns raw pointer to the libwayland backend
    pub const fn as_raw(self) -> NonNull<wl_proxy> {
        self.raw
    }
}

impl fmt::Debug for WlProxyBorrow<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct(std::any::type_name::<Self>())
            .finish_non_exhaustive()
    }
}

impl AsProxy for WlProxyBorrow<'_> {
    fn as_proxy(&self) -> WlProxyBorrow<'_> {
        *self
    }
}

pub trait AsProxy {
    fn as_proxy(&self) -> WlProxyBorrow<'_>;
}
static_assertions::assert_obj_safe!(AsProxy);

// TODO(hack3rmann): missing docs
pub struct WlProxyQuery<T> {
    // TODO(hack3rmann): determine a nice API for object querying
    raw: *const wl_proxy,
    // TODO(hack3rmann): determine variance
    _p: PhantomData<fn() -> T>,
}

impl<T: AsProxy> WlProxyQuery<T> {
    pub const unsafe fn from_raw(raw: *const wl_proxy) -> Self {
        Self {
            raw,
            _p: PhantomData,
        }
    }

    pub const unsafe fn into_raw(self) -> *const wl_proxy {
        self.raw
    }
}

impl<T> Clone for WlProxyQuery<T> {
    fn clone(&self) -> Self {
        Self {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}

impl<T> Copy for WlProxyQuery<T> {}

impl<T> fmt::Debug for WlProxyQuery<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct(std::any::type_name::<Self>())
            .finish_non_exhaustive()
    }
}

impl<T> PartialEq for WlProxyQuery<T> {
    fn eq(&self, other: &Self) -> bool {
        self.raw == other.raw
    }
}

#[derive(Clone, PartialEq, Copy)]
pub struct WlDynProxyQuery {
    // TODO(hack3rmann): determine a nice API for object querying
    raw: *const wl_proxy,
}

impl WlDynProxyQuery {
    pub const unsafe fn from_raw(raw: *const wl_proxy) -> Self {
        Self { raw }
    }
}

impl fmt::Debug for WlDynProxyQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct(std::any::type_name::<Self>())
            .finish_non_exhaustive()
    }
}

macro_rules! define_proxies {
    ( $( $Proxy:ident ),* $(,)? ) => {
        $(
            pub struct $Proxy {
                pub(crate) proxy: WlProxy,
            }

            impl AsProxy for $Proxy {
                fn as_proxy(&self) -> WlProxyBorrow<'_> {
                    self.proxy.as_proxy()
                }
            }

            impl From<WlProxy> for $Proxy {
                fn from(proxy: WlProxy) -> Self {
                    Self { proxy }
                }
            }

            impl fmt::Debug for $Proxy {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_struct(std::any::type_name::<Self>())
                        .finish_non_exhaustive()
                }
            }
        )*
    };
}

define_proxies! {
    WlRegistry, WlCompositor, WlRegion, WlBuffer, WlSurface, WlOutput,
    WlShm, WlShmPool, ZwlrLayerShellV1, ZwlrLayerSurfaceV1,
}
