pub mod display;
pub mod object;
pub mod object_storage;
pub mod proxy;
pub mod wire;

pub mod protocols {
    use wayland_scanner::include_wl_interfaces;

    include_wl_interfaces!("wayland-protocols/wayland.xml");

    include_wl_interfaces!("wayland-protocols/stable/xdg-shell/xdg-shell.xml");

    include_wl_interfaces!("wayland-protocols/stable/viewporter/viewporter.xml");

    include_wl_interfaces!(
        "wayland-protocols/wlr-protocols/unstable/wlr-layer-shell-unstable-v1.xml"
    );
}

use crate::object::ObjectId;
use core::fmt;
use std::{ffi::CStr, num::NonZeroU32};
use wayland_sys::Interface;
use wayland_sys::wl_interface;
use wire::OpCode;

#[derive(Clone, Debug, PartialEq, Default, Copy, Eq, PartialOrd, Ord, Hash)]
pub enum ObjectType {
    // globals
    #[default]
    Display,
    Registry,
    Compositor,
    ShmPool,
    Shm,
    Buffer,
    Surface,
    Output,
    Region,
    WlrLayerShellV1,
    Viewporter,
    // non-globals
    Viewport,
    Callback,
    WlrLayerSurfaceV1,
}

impl ObjectType {
    /// Constructs [`ObjectType`] from its name
    pub fn from_interface_name(name: &str) -> Option<Self> {
        static MAP: phf::Map<&'static str, ObjectType> = phf::phf_map! {
            // globals
            "wl_display" => ObjectType::Display,
            "wl_registry" => ObjectType::Registry,
            "wl_compositor" => ObjectType::Compositor,
            "wl_shm_pool" => ObjectType::ShmPool,
            "wl_shm" => ObjectType::Shm,
            "wl_buffer" => ObjectType::Buffer,
            "wl_surface" => ObjectType::Surface,
            "wl_region" => ObjectType::Region,
            "wl_output" => ObjectType::Output,
            "zwlr_layer_shell_v1" => ObjectType::WlrLayerShellV1,
            "wp_viewporter" => ObjectType::Viewporter,
            // non-globals
            "wp_viewport" => ObjectType::Viewport,
            "wl_callback" => ObjectType::Callback,
            "zwlr_layer_surface_v1" => ObjectType::WlrLayerSurfaceV1,
        };

        MAP.get(name).copied()
    }

    /// The [`Interface`] generated by wayland-scanner for this object type
    pub const fn interface(self) -> &'static Interface<'static> {
        match self {
            Self::Display => &protocols::wl_display::INTERFACE,
            Self::Surface => &protocols::wl_surface::INTERFACE,
            Self::Region => &protocols::wl_region::INTERFACE,
            Self::Callback => &protocols::wl_callback::INTERFACE,
            Self::Registry => &protocols::wl_registry::INTERFACE,
            Self::ShmPool => &protocols::wl_shm_pool::INTERFACE,
            Self::Compositor => &protocols::wl_compositor::INTERFACE,
            Self::Shm => &protocols::wl_shm::INTERFACE,
            Self::Buffer => &protocols::wl_buffer::INTERFACE,
            Self::Output => &protocols::wl_output::INTERFACE,
            Self::WlrLayerShellV1 => &protocols::zwlr_layer_shell_v1::INTERFACE,
            Self::WlrLayerSurfaceV1 => &protocols::zwlr_layer_surface_v1::INTERFACE,
            Self::Viewporter => &protocols::wp_viewporter::INTERFACE,
            Self::Viewport => &protocols::wp_viewport::INTERFACE,
        }
    }

    /// The [`wl_interface`] generated by wayland-scanner for this object type
    pub const fn backend_interface(self) -> &'static wl_interface {
        match self {
            Self::Display => &protocols::wl_display::WL_INTERFACE,
            Self::Surface => &protocols::wl_surface::WL_INTERFACE,
            Self::Region => &protocols::wl_region::WL_INTERFACE,
            Self::Callback => &protocols::wl_callback::WL_INTERFACE,
            Self::Registry => &protocols::wl_registry::WL_INTERFACE,
            Self::ShmPool => &protocols::wl_shm_pool::WL_INTERFACE,
            Self::Compositor => &protocols::wl_compositor::WL_INTERFACE,
            Self::Shm => &protocols::wl_shm::WL_INTERFACE,
            Self::Buffer => &protocols::wl_buffer::WL_INTERFACE,
            Self::Output => &protocols::wl_output::WL_INTERFACE,
            Self::WlrLayerShellV1 => &protocols::zwlr_layer_shell_v1::WL_INTERFACE,
            Self::WlrLayerSurfaceV1 => &protocols::zwlr_layer_surface_v1::WL_INTERFACE,
            Self::Viewporter => &protocols::wp_viewporter::WL_INTERFACE,
            Self::Viewport => &protocols::wp_viewport::WL_INTERFACE,
        }
    }

    /// The name of this interface
    pub const fn interface_name(self) -> &'static str {
        unsafe { self.interface().name_str_unchecked() }
    }

    /// The for the particular request in this interface
    ///
    /// # Error
    ///
    /// Will panic if there is no request for this `opcode`
    pub const fn request_name(self, opcode: OpCode) -> &'static str {
        unsafe { self.interface().methods[opcode as usize].name_str_unchecked() }
    }

    /// The for the particular event in this interface
    ///
    /// # Error
    ///
    /// Will panic if there is no event for this `opcode`
    pub const fn event_name(self, opcode: OpCode) -> &'static str {
        unsafe { self.interface().events[opcode as usize].name_str_unchecked() }
    }
}

impl fmt::Display for ObjectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.interface_name())
    }
}

/// Assocciated `ObjectType`
pub trait HasObjectType {
    const OBJECT_TYPE: ObjectType;
}

/// The type and the integer name for the global object.
#[derive(Clone, Debug, PartialEq, Copy, Eq, PartialOrd, Ord, Hash)]
pub struct InterfaceMessageArgument {
    pub object_type: ObjectType,
    pub name: ObjectId,
}

impl InterfaceMessageArgument {
    /// Interface name
    pub const fn interface(self) -> &'static CStr {
        self.object_type.interface().name
    }

    /// Minimal version supported by this crate
    pub const fn min_supported_version(self) -> NonZeroU32 {
        match self.object_type {
            ObjectType::Shm => const { NonZeroU32::new(1).unwrap() },
            _ => self.version(),
        }
    }

    /// Version stored in the interface
    pub const fn version(self) -> NonZeroU32 {
        self.object_type.interface().version
    }

    /// Integer name for this interface
    pub const fn name(self) -> ObjectId {
        self.name
    }
}

#[cfg(test)]
mod tests {
    use std::{ffi::CStr, slice};
    use wayland_sys::{count_arguments_from_message_signature, wl_interface, wl_message};

    fn check_wl_messages_arrays_are_the_same(
        lhs_ptr: *const wl_message,
        lhs_len: i32,
        rhs_ptr: *const wl_message,
        rhs_len: i32,
    ) {
        assert!(lhs_len >= 0 && rhs_len == lhs_len);

        if !lhs_ptr.is_null() && !rhs_ptr.is_null() {
            let left_methods = unsafe { slice::from_raw_parts(lhs_ptr, lhs_len as usize) };
            let right_methods = unsafe { slice::from_raw_parts(rhs_ptr, rhs_len as usize) };

            for (left, right) in left_methods.iter().zip(right_methods) {
                check_wl_messages_are_the_same(left, right)
            }
        }
    }

    fn check_wl_messages_are_the_same(lhs: &wl_message, rhs: &wl_message) {
        assert!(!lhs.name.is_null() && !rhs.name.is_null());

        let left_name = unsafe { CStr::from_ptr(lhs.name) };
        let right_name = unsafe { CStr::from_ptr(rhs.name) };

        assert_eq!(left_name, right_name, "same names");

        if lhs.signature.is_null() && rhs.signature.is_null() {
            return;
        }

        assert!(
            !lhs.signature.is_null() && !rhs.signature.is_null(),
            "both signatures are present in the {left_name:?} message",
        );

        let left_signature = unsafe { CStr::from_ptr(lhs.signature) };
        let right_signature = unsafe { CStr::from_ptr(rhs.signature) };

        assert_eq!(
            left_signature, right_signature,
            "same signatures for the {left_name:?} message",
        );

        let signature = left_signature;

        let n_args = count_arguments_from_message_signature(signature);

        if lhs.types.is_null() && rhs.types.is_null() {
            return;
        }

        assert!(
            !lhs.types.is_null() && !rhs.types.is_null(),
            "both type arrays are present for the {left_name:?} message, left is {:?}, right is {:?}",
            lhs.types,
            rhs.types,
        );

        let left_interfaces = unsafe { slice::from_raw_parts(lhs.types, n_args) };
        let right_interfaces = unsafe { slice::from_raw_parts(rhs.types, n_args) };

        for (&left, &right) in left_interfaces.iter().zip(right_interfaces) {
            if left.is_null() && right.is_null() {
                continue;
            }

            let left = unsafe { left.as_ref().expect("left interface is null") };
            let right = unsafe { right.as_ref().expect("right interface is null") };

            check_wl_interfaces_are_the_same(left, right, CheckDepth::Shallow);
        }
    }

    #[derive(Clone, Debug, PartialEq, Default, Copy, Eq, PartialOrd, Ord, Hash)]
    enum CheckDepth {
        Shallow,
        #[default]
        Deep,
    }

    fn check_wl_interfaces_are_the_same(lhs: &wl_interface, rhs: &wl_interface, depth: CheckDepth) {
        assert!(
            !lhs.name.is_null() && !rhs.name.is_null(),
            "both names exist"
        );

        let left_name = unsafe { CStr::from_ptr(lhs.name) };
        let right_name = unsafe { CStr::from_ptr(rhs.name) };

        assert_eq!(left_name, right_name, "same names");
        assert_eq!(lhs.version, rhs.version, "same versions");

        if let CheckDepth::Deep = depth {
            eprintln!("checking requests are the same in {left_name:?} interface");

            check_wl_messages_arrays_are_the_same(
                lhs.methods,
                lhs.method_count,
                rhs.methods,
                rhs.method_count,
            );

            eprintln!("checking events are the same in {left_name:?} interface");

            check_wl_messages_arrays_are_the_same(
                lhs.events,
                lhs.event_count,
                rhs.events,
                rhs.event_count,
            );
        }
    }

    macro_rules! define_interface_tests {
        ( $( $interface:ident ),* $(,)? ) => {
            $(
                ::paste::paste! {
                    #[test]
                    fn [< $interface _the_same >] () {
                        let external = unsafe { &::wayland_sys:: [< $interface _interface >] };
                        let internal = & $crate ::sys::protocols:: $interface ::WL_INTERFACE;

                        check_wl_interfaces_are_the_same(external, internal, CheckDepth::Deep);
                    }
                }
            )*
        };
    }

    define_interface_tests!(
        wl_display,
        wl_registry,
        wl_callback,
        wl_compositor,
        wl_shm_pool,
        wl_shm,
        wl_buffer,
        wl_data_offer,
        wl_data_source,
        wl_data_device,
        wl_data_device_manager,
        wl_shell,
        wl_shell_surface,
        wl_surface,
        wl_seat,
        wl_pointer,
        wl_keyboard,
        wl_touch,
        wl_output,
        wl_region,
        wl_subcompositor,
        wl_subsurface,
    );
}
