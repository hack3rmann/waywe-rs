use crate::sys::{protocol, wire::OpCode};
use std::{ffi::CStr, fmt, num::NonZeroU32};
use thiserror::Error;
use wayland_sys::{Interface, wl_interface};

/// Ids and names for Wayland objects
#[derive(Clone, Debug, PartialEq, Eq, Copy, PartialOrd, Ord)]
pub struct WlObjectId(pub NonZeroU32);

impl WlObjectId {
    /// Makes new id from `u32`
    ///
    /// # Panic
    ///
    /// Panics if `value == 0`.
    pub const fn new(value: u32) -> Self {
        Self(NonZeroU32::new(value).unwrap())
    }
}

impl Default for WlObjectId {
    fn default() -> Self {
        Self::new(1)
    }
}

impl std::hash::Hash for WlObjectId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write_u32(u32::from(*self));
    }
}

impl From<WlObjectId> for u32 {
    fn from(value: WlObjectId) -> Self {
        value.0.get()
    }
}

impl TryFrom<u32> for WlObjectId {
    type Error = ZeroObjectIdError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        Ok(Self(NonZeroU32::new(value).ok_or(ZeroObjectIdError)?))
    }
}

#[derive(Debug, Error)]
#[error("invalid zero `ObjectId`")]
pub struct ZeroObjectIdError;

// FIXME(hack3rmann): remove
pub use crate::interface::generated::WlObjectType;

impl WlObjectType {
    /// Constructs [`ObjectType`] from its name
    pub fn from_interface_name(name: &str) -> Option<Self> {
        static MAP: phf::Map<&'static str, WlObjectType> = phf::phf_map! {
            // globals
            "wl_display" => WlObjectType::WlDisplay,
            "wl_registry" => WlObjectType::WlRegistry,
            "wl_compositor" => WlObjectType::WlCompositor,
            "wl_shm_pool" => WlObjectType::WlShmPool,
            "wl_shm" => WlObjectType::WlShm,
            "wl_buffer" => WlObjectType::WlBuffer,
            "wl_surface" => WlObjectType::WlSurface,
            "wl_region" => WlObjectType::WlRegion,
            "wl_output" => WlObjectType::WlOutput,
            "zwlr_layer_shell_v1" => WlObjectType::ZwlrLayerShellV1,
            "wp_viewporter" => WlObjectType::WpViewporter,
            "xdg_wm_base" => WlObjectType::XdgWmBase,
            // non-globals
            "wp_viewport" => WlObjectType::WpViewport,
            "wl_callback" => WlObjectType::WlCallback,
            "zwlr_layer_surface_v1" => WlObjectType::ZwlrLayerSurfaceV1,
            "xdg_surface" => WlObjectType::XdgSurface,
            "xdg_toplevel" => WlObjectType::XdgToplevel,
        };

        MAP.get(name).copied()
    }

    /// The [`Interface`] generated by wayland-scanner for this object type
    pub const fn interface(self) -> &'static Interface<'static> {
        match self {
            Self::WlDisplay => &protocol::wl_display::INTERFACE,
            Self::WlSurface => &protocol::wl_surface::INTERFACE,
            Self::WlRegion => &protocol::wl_region::INTERFACE,
            Self::WlCallback => &protocol::wl_callback::INTERFACE,
            Self::WlRegistry => &protocol::wl_registry::INTERFACE,
            Self::WlShmPool => &protocol::wl_shm_pool::INTERFACE,
            Self::WlCompositor => &protocol::wl_compositor::INTERFACE,
            Self::WlShm => &protocol::wl_shm::INTERFACE,
            Self::WlBuffer => &protocol::wl_buffer::INTERFACE,
            Self::WlOutput => &protocol::wl_output::INTERFACE,
            Self::ZwlrLayerShellV1 => &protocol::zwlr_layer_shell_v1::INTERFACE,
            Self::ZwlrLayerSurfaceV1 => &protocol::zwlr_layer_surface_v1::INTERFACE,
            Self::WpViewporter => &protocol::wp_viewporter::INTERFACE,
            Self::WpViewport => &protocol::wp_viewport::INTERFACE,
            Self::XdgWmBase => &protocol::xdg_wm_base::INTERFACE,
            Self::XdgSurface => &protocol::xdg_surface::INTERFACE,
            Self::XdgToplevel => &protocol::xdg_toplevel::INTERFACE,
            _ => todo!(),
        }
    }

    /// The [`wl_interface`] generated by wayland-scanner for this object type
    pub const fn backend_interface(self) -> &'static wl_interface {
        match self {
            Self::WlDisplay => &protocol::wl_display::WL_INTERFACE,
            Self::WlSurface => &protocol::wl_surface::WL_INTERFACE,
            Self::WlRegion => &protocol::wl_region::WL_INTERFACE,
            Self::WlCallback => &protocol::wl_callback::WL_INTERFACE,
            Self::WlRegistry => &protocol::wl_registry::WL_INTERFACE,
            Self::WlShmPool => &protocol::wl_shm_pool::WL_INTERFACE,
            Self::WlCompositor => &protocol::wl_compositor::WL_INTERFACE,
            Self::WlShm => &protocol::wl_shm::WL_INTERFACE,
            Self::WlBuffer => &protocol::wl_buffer::WL_INTERFACE,
            Self::WlOutput => &protocol::wl_output::WL_INTERFACE,
            Self::ZwlrLayerShellV1 => &protocol::zwlr_layer_shell_v1::WL_INTERFACE,
            Self::ZwlrLayerSurfaceV1 => &protocol::zwlr_layer_surface_v1::WL_INTERFACE,
            Self::WpViewporter => &protocol::wp_viewporter::WL_INTERFACE,
            Self::WpViewport => &protocol::wp_viewport::WL_INTERFACE,
            Self::XdgWmBase => &protocol::xdg_wm_base::WL_INTERFACE,
            Self::XdgSurface => &protocol::xdg_surface::WL_INTERFACE,
            Self::XdgToplevel => &protocol::xdg_toplevel::WL_INTERFACE,
            _ => todo!()
        }
    }

    /// The name of this interface
    pub const fn interface_name(self) -> &'static str {
        unsafe { self.interface().name_str_unchecked() }
    }

    /// The for the particular request in this interface
    ///
    /// # Error
    ///
    /// Will return [`None`] if there is no request for this `opcode`
    pub const fn request_name(self, opcode: OpCode) -> Option<&'static str> {
        let index = opcode as usize;

        // HACK(const-fn): should be slice.get(index)
        if index >= self.interface().methods.len() {
            return None;
        }

        Some(unsafe { self.interface().methods[index].name_str_unchecked() })
    }

    /// The for the particular event in this interface
    ///
    /// # Error
    ///
    /// Will return [`None`] if there is no event for this `opcode`
    pub const fn event_name(self, opcode: OpCode) -> Option<&'static str> {
        let index = opcode as usize;

        // HACK(const-fn): should be slice.get(index)
        if index >= self.interface().methods.len() {
            return None;
        }

        Some(unsafe { self.interface().events[opcode as usize].name_str_unchecked() })
    }
}

impl fmt::Display for WlObjectType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.interface_name())
    }
}

/// Assocciated `ObjectType`
pub trait HasObjectType {
    const OBJECT_TYPE: crate::interface::generated::WlObjectType;
}

/// The type and the integer name for the global object.
#[derive(Clone, Debug, PartialEq, Copy, Eq, PartialOrd, Ord, Hash)]
pub struct InterfaceMessageArgument {
    pub object_type: WlObjectType,
    pub name: WlObjectId,
}

impl InterfaceMessageArgument {
    /// Interface name
    pub const fn interface(self) -> &'static CStr {
        self.object_type.interface().name
    }

    /// Minimal version supported by this crate
    pub const fn min_supported_version(self) -> NonZeroU32 {
        match self.object_type {
            WlObjectType::WlShm => const { NonZeroU32::new(1).unwrap() },
            _ => self.version(),
        }
    }

    /// Version stored in the interface
    pub const fn version(self) -> NonZeroU32 {
        self.object_type.interface().version
    }

    /// Integer name for this interface
    pub const fn name(self) -> WlObjectId {
        self.name
    }
}
