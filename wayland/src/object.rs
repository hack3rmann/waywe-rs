use std::{ffi::CStr, fmt, num::NonZeroU32};
use thiserror::Error;
use wayland_sys::{wl_interface, Interface};

use crate::sys::wire::OpCode;

/// Ids and names for Wayland objects
#[derive(Clone, Debug, PartialEq, Eq, Copy, PartialOrd, Ord)]
pub struct WlObjectId(pub NonZeroU32);

impl WlObjectId {
    /// Makes new id from `u32`
    ///
    /// # Panic
    ///
    /// Panics if `value == 0`.
    pub const fn new(value: u32) -> Self {
        Self(NonZeroU32::new(value).unwrap())
    }
}

impl Default for WlObjectId {
    fn default() -> Self {
        Self::new(1)
    }
}

impl std::hash::Hash for WlObjectId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        state.write_u32(u32::from(*self));
    }
}

impl From<WlObjectId> for u32 {
    fn from(value: WlObjectId) -> Self {
        value.0.get()
    }
}

impl TryFrom<u32> for WlObjectId {
    type Error = ZeroObjectIdError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        Ok(Self(NonZeroU32::new(value).ok_or(ZeroObjectIdError)?))
    }
}

#[derive(Debug, Error)]
#[error("invalid zero `ObjectId`")]
pub struct ZeroObjectIdError;

#[derive(Clone, Debug, PartialEq, Default, Copy, Eq, PartialOrd, Ord, Hash)]
pub enum WlObjectType {
    // globals
    #[default]
    Display,
    Registry,
    Compositor,
    ShmPool,
    Shm,
    Buffer,
    Surface,
    Output,
    Region,
    LayerShell,
    Viewporter,
    // non-globals
    Viewport,
    Callback,
    LayerSurface,
}

impl WlObjectType {
    /// Constructs [`ObjectType`] from its name
    pub fn from_interface_name(name: &str) -> Option<Self> {
        static MAP: phf::Map<&'static str, WlObjectType> = phf::phf_map! {
            // globals
            "wl_display" => WlObjectType::Display,
            "wl_registry" => WlObjectType::Registry,
            "wl_compositor" => WlObjectType::Compositor,
            "wl_shm_pool" => WlObjectType::ShmPool,
            "wl_shm" => WlObjectType::Shm,
            "wl_buffer" => WlObjectType::Buffer,
            "wl_surface" => WlObjectType::Surface,
            "wl_region" => WlObjectType::Region,
            "wl_output" => WlObjectType::Output,
            "zwlr_layer_shell_v1" => WlObjectType::LayerShell,
            "wp_viewporter" => WlObjectType::Viewporter,
            // non-globals
            "wp_viewport" => WlObjectType::Viewport,
            "wl_callback" => WlObjectType::Callback,
            "zwlr_layer_surface_v1" => WlObjectType::LayerSurface,
        };

        MAP.get(name).copied()
    }

    /// The [`Interface`] generated by wayland-scanner for this object type
    pub const fn interface(self) -> &'static Interface<'static> {
        match self {
            Self::Display => &crate::sys::protocol::wl_display::INTERFACE,
            Self::Surface => &crate::sys::protocol::wl_surface::INTERFACE,
            Self::Region => &crate::sys::protocol::wl_region::INTERFACE,
            Self::Callback => &crate::sys::protocol::wl_callback::INTERFACE,
            Self::Registry => &crate::sys::protocol::wl_registry::INTERFACE,
            Self::ShmPool => &crate::sys::protocol::wl_shm_pool::INTERFACE,
            Self::Compositor => &crate::sys::protocol::wl_compositor::INTERFACE,
            Self::Shm => &crate::sys::protocol::wl_shm::INTERFACE,
            Self::Buffer => &crate::sys::protocol::wl_buffer::INTERFACE,
            Self::Output => &crate::sys::protocol::wl_output::INTERFACE,
            Self::LayerShell => &crate::sys::protocol::zwlr_layer_shell_v1::INTERFACE,
            Self::LayerSurface => &crate::sys::protocol::zwlr_layer_surface_v1::INTERFACE,
            Self::Viewporter => &crate::sys::protocol::wp_viewporter::INTERFACE,
            Self::Viewport => &crate::sys::protocol::wp_viewport::INTERFACE,
        }
    }

    /// The [`wl_interface`] generated by wayland-scanner for this object type
    pub const fn backend_interface(self) -> &'static wl_interface {
        match self {
            Self::Display => &crate::sys::protocol::wl_display::WL_INTERFACE,
            Self::Surface => &crate::sys::protocol::wl_surface::WL_INTERFACE,
            Self::Region => &crate::sys::protocol::wl_region::WL_INTERFACE,
            Self::Callback => &crate::sys::protocol::wl_callback::WL_INTERFACE,
            Self::Registry => &crate::sys::protocol::wl_registry::WL_INTERFACE,
            Self::ShmPool => &crate::sys::protocol::wl_shm_pool::WL_INTERFACE,
            Self::Compositor => &crate::sys::protocol::wl_compositor::WL_INTERFACE,
            Self::Shm => &crate::sys::protocol::wl_shm::WL_INTERFACE,
            Self::Buffer => &crate::sys::protocol::wl_buffer::WL_INTERFACE,
            Self::Output => &crate::sys::protocol::wl_output::WL_INTERFACE,
            Self::LayerShell => &crate::sys::protocol::zwlr_layer_shell_v1::WL_INTERFACE,
            Self::LayerSurface => &crate::sys::protocol::zwlr_layer_surface_v1::WL_INTERFACE,
            Self::Viewporter => &crate::sys::protocol::wp_viewporter::WL_INTERFACE,
            Self::Viewport => &crate::sys::protocol::wp_viewport::WL_INTERFACE,
        }
    }

    /// The name of this interface
    pub const fn interface_name(self) -> &'static str {
        unsafe { self.interface().name_str_unchecked() }
    }

    /// The for the particular request in this interface
    ///
    /// # Error
    ///
    /// Will return [`None`] if there is no request for this `opcode`
    pub const fn request_name(self, opcode: OpCode) -> Option<&'static str> {
        let index = opcode as usize;

        // HACK(const-fn): should be slice.get(index)
        if index >= self.interface().methods.len() {
            return None;
        }

        Some(unsafe { self.interface().methods[index].name_str_unchecked() })
    }

    /// The for the particular event in this interface
    ///
    /// # Error
    ///
    /// Will return [`None`] if there is no event for this `opcode`
    pub const fn event_name(self, opcode: OpCode) -> Option<&'static str> {
        let index = opcode as usize;

        // HACK(const-fn): should be slice.get(index)
        if index >= self.interface().methods.len() {
            return None;
        }

        Some(unsafe { self.interface().events[opcode as usize].name_str_unchecked() })
    }
}

impl fmt::Display for WlObjectType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.interface_name())
    }
}

/// Assocciated `ObjectType`
pub trait HasObjectType {
    const OBJECT_TYPE: WlObjectType;
}

/// The type and the integer name for the global object.
#[derive(Clone, Debug, PartialEq, Copy, Eq, PartialOrd, Ord, Hash)]
pub struct InterfaceMessageArgument {
    pub object_type: WlObjectType,
    pub name: WlObjectId,
}

impl InterfaceMessageArgument {
    /// Interface name
    pub const fn interface(self) -> &'static CStr {
        self.object_type.interface().name
    }

    /// Minimal version supported by this crate
    pub const fn min_supported_version(self) -> NonZeroU32 {
        match self.object_type {
            WlObjectType::Shm => const { NonZeroU32::new(1).unwrap() },
            _ => self.version(),
        }
    }

    /// Version stored in the interface
    pub const fn version(self) -> NonZeroU32 {
        self.object_type.interface().version
    }

    /// Integer name for this interface
    pub const fn name(self) -> WlObjectId {
        self.name
    }
}
